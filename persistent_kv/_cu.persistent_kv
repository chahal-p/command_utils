#!/usr/bin/env bash

set -eo pipefail

CU_SUCCESS=0
CU_ERROR=1
CU_ERROR_USAGE=2
CU_ERROR_NOT_FOUND=40
CU_ERROR_ALREADY_EXISTS=41

function echo_err() {
  echo "cu.persistent_kv: $@" >&2
}

function usage() {
  echo "Usage: $(basename "${0}") <subcommand> <namespace> <key>"
  echo "Subcommands:"
  echo "  list"
  echo "  get"
  echo "  set"
  echo "  set_overwrite"
  echo "  delete"
  echo "  chmod"
  echo "  chown"
  echo ""
  echo "In set or set_overwrite subcommand, stdin is used as the value"
}

source _cu.persistent_kv.configs || { echo_err "Failed to load persistent_kv configs"; exit $CU_ERROR; }
LOCK_DIR="/tmp/cu_persistent_kv_locks"

[[ -d "${STORAGE_DIR}" ]] || { echo_err "Storage directory ${STORAGE_DIR} does not exist"; exit $CU_ERROR; }
[[ -d "${LOCK_DIR}" ]] || mkdir -m 777 -p "${LOCK_DIR}" || exit

subcommand="$1"
namespace="$2"
key="$3"
mode="$4"
owner_group="$5"

if [[ -n "${namespace}" ]]; then
  [[ "${#namespace}" -le 64 ]] || { echo_err "Invalid namespace: namespace should be at most 64 characters long"; exit $CU_ERROR_USAGE; }
  [[ "${namespace}" =~ ^[a-zA-Z0-9_-]+$ ]] || { echo_err "Invalid namespace: namespace should match regex ^[a-zA-Z0-9_-]+$"; exit $CU_ERROR_USAGE; }
fi


########## BEGIN list subcommand ##########

if [[ "${subcommand}" == "list" ]]; then
  ls "${STORAGE_DIR}" > /dev/null 2>&1 || { echo_err "Failed to list directory"; exit $CU_ERROR; }
  items=()
  ns_filter=''
  [ -n "$namespace" ] && ns_filter="^${namespace}\."
  for x in $(ls -1 --color=never "${STORAGE_DIR}" | grep "$ns_filter"); do
    [ -r "${STORAGE_DIR%/}/${x}" ] || continue
    IFS='.' read -r n k <<< "${x}"
    if [[ -z "${namespace}" ]]; then
      items+=("${n}")
    elif [[ "${n}" == "${namespace}" ]]; then
      items+=("${k}")
    fi
  done
  if [[ ${#items[@]} -eq 0 ]]; then
    [[ -z "${namespace}" ]] || { echo_err "Namespace ${namespace} not found"; exit $CU_ERROR_NOT_FOUND; }
  else
    printf '%s\n' "${items[@]}" | sort -u
  fi
  exit
fi
########## END list subcommand ##########

if [[ -z "${namespace}" || -z "${key}" ]]; then
  echo_err "Namespace and key are required"
  exit $CU_ERROR_USAGE 
fi

if [[ -n "${key}" ]]; then
  [[ "${#key}" -le 64 ]] || { echo_err "Invalid key: key should be at most 64 characters long"; exit $CU_ERROR_USAGE; }
  [[ "${key}" =~ ^[a-zA-Z0-9_-]+$ ]] || { echo_err "Invalid key: key should match regex ^[a-zA-Z0-9_-]+$"; exit $CU_ERROR_USAGE; }
fi

key_file="${STORAGE_DIR}/${namespace}.${key}"

key_lock_path="${LOCK_DIR}/${namespace}.${key}.lock"
(umask 000 && touch "${key_lock_path}") || { echo_err "Failed to create lock file"; exit $CU_ERROR; }

lock_cmd="flock"
cu.is_macos && lock_cmd="lockf"

# BEGIN Critical section
# Acquire lock
exec 200<"${key_lock_path}"
$lock_cmd 200

########## BEGIN get subcommand ##########
if [[ "${subcommand}" == "get" ]]; then
  [ -f "${key_file}" ] || { echo_err "Key ${key} in namespace ${namespace} not found"; exit $CU_ERROR_NOT_FOUND; }
  [ -r "${key_file}" ] || { echo_err "Permission denied: Key ${key} in namespace ${namespace} is not readable"; exit $CU_ERROR; }
  cat "${key_file}" || { echo_err "Failed to get value for key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END get subcommand ##########

########## BEGIN set subcommand ##########
if [[ "${subcommand}" == "set" || "${subcommand}" == "set_overwrite" ]]; then
  if [ -f "${key_file}" ]; then
    [ "${subcommand}" == "set" ] && { echo_err "Key ${key} in namespace ${namespace} already exists"; exit $CU_ERROR_ALREADY_EXISTS; }
  else
    (umask 137 && touch "${key_file}") || { echo_err "Failed to create key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  fi
  cat - > "${key_file}" || { echo_err "Failed to set value for key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END set subcommand ##########

########## BEGIN delete subcommand ##########
if [[ "${subcommand}" == "delete" ]]; then
  [ -f "${key_file}" ] || { echo_err "Key ${key} in namespace ${namespace} not found"; exit $CU_ERROR_NOT_FOUND; }
  rm "${key_file}" > /dev/null 2>&1 || { echo_err "Failed to delete key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END delete subcommand ##########

########## BEGIN chmod subcommand ##########
if [[ "${subcommand}" == "chmod" ]]; then
  [ -f "${key_file}" ] || { echo_err "Key ${key} in namespace ${namespace} not found"; exit $CU_ERROR_NOT_FOUND; }
  chmod "${mode}" "${key_file}" || { echo_err "Failed to set mode for key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END chmod subcommand ##########

########## BEGIN chown subcommand ##########
if [[ "${subcommand}" == "chown" ]]; then
  [ -f "${key_file}" ] || { echo_err "Key ${key} in namespace ${namespace} not found"; exit $CU_ERROR_NOT_FOUND; }
  chown "${owner_group}" "${key_file}" || { echo_err "Failed to set owner/group for key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END chown subcommand ##########

echo_err "Unknown subcommand: ${subcommand}"
usage
exit $CU_ERROR_USAGE

# END Critical section
