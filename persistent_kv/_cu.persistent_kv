#!/usr/bin/env bash

set -eo pipefail

CU_SUCCESS=0
CU_ERROR=1
CU_ERROR_USAGE=2
CU_ERROR_NOT_FOUND=40
CU_ERROR_ALREADY_EXISTS=41

USER="$(id -un)" || { echo_err "Failed to get user name"; exit 1; }

ROOT_DIR="${HOME}/.local/share/command_utils/persistent_kv_data"
LOCK_DIR="/tmp/cu_persistent_kv_locks_${USER}"

function echo_err() {
  echo "cu.persistent_kv: $@" >&2
}

function usage() {
  echo "Usage: $(basename "${0}") <subcommand> <namespace> <key>"
  echo "Subcommands:"
  echo "  list"
  echo "  get"
  echo "  set"
  echo "  set_overwrite"
  echo "  delete"
  echo ""
  echo "In set or set_overwrite subcommand, stdin is used as the value"
}

[[ -d "${ROOT_DIR}" ]] || mkdir -m 777 -p "${ROOT_DIR}" || exit
[[ -d "${LOCK_DIR}" ]] || mkdir -m 777 -p "${LOCK_DIR}" || exit

subcommand="$1"
namespace="$2"
key="$3"

if [[ "${subcommand}" =~ ^get|set|delete$ ]]; then
  if [[ -z "${namespace}" || -z "${key}" ]]; then
    echo_err "Namespace and key are required"
    exit $CU_ERROR_USAGE 
  fi
elif [[ "${subcommand}" != "list" ]]; then
  echo_err "Unknown subcommand: ${subcommand}"
  usage
  exit $CU_ERROR_USAGE
fi

if [[ -n "${namespace}" ]]; then
  [[ "${#namespace}" -le 64 ]] || { echo_err "Invalid namespace: namespace should be at most 64 characters long"; exit $CU_ERROR_USAGE; }
  [[ "${namespace}" =~ ^[a-zA-Z0-9_-]+$ ]] || { echo_err "Invalid namespace: namespace should match regex ^[a-zA-Z0-9_-]+$"; exit $CU_ERROR_USAGE; }
fi

if [[ -n "${key}" ]]; then
  [[ "${#key}" -le 64 ]] || { echo_err "Invalid key: key should be at most 64 characters long"; exit $CU_ERROR_USAGE; }
  [[ "${key}" =~ ^[a-zA-Z0-9_-]+$ ]] || { echo_err "Invalid key: key should match regex ^[a-zA-Z0-9_-]+$"; exit $CU_ERROR_USAGE; }
fi

########## BEGIN list subcommand ##########

if [[ "${subcommand}" == "list" ]]; then
  ls "${ROOT_DIR}" > /dev/null 2>&1 || { echo_err "Failed to list directory"; exit $CU_ERROR; }
  items=()
  ns_filter=''
  [ -n "$namespace" ] && ns_filter="^${namespace}\."
  for x in $(ls -1 --color=never "${ROOT_DIR}" | grep "$ns_filter"); do
    [ -r "${ROOT_DIR%/}/${x}" ] || continue
    IFS='.' read -r n k <<< "${x}"
    if [[ -z "${namespace}" ]]; then
      items+=("${n}")
    elif [[ "${n}" == "${namespace}" ]]; then
      items+=("${k}")
    fi
  done
  if [[ ${#items[@]} -eq 0 ]]; then
    [[ -z "${namespace}" ]] || { echo_err "Namespace ${namespace} not found"; exit $CU_ERROR_NOT_FOUND; }
  else
    printf '%s\n' "${items[@]}" | sort -u
  fi
  exit
fi
########## END list subcommand ##########

key_file="${ROOT_DIR}/${namespace}.${key}"

# Acquire lock key path
lock_cmd="flock"
cu.is_macos && lock_cmd="lockf"

key_lock_path="${LOCK_DIR}/${namespace}.${key}.lock"
(umask 000 && touch "${key_lock_path}") || { echo_err "Failed to create lock file"; exit $CU_ERROR; }

exec 200<"${key_lock_path}"
$lock_cmd 200

# BEGIN Critical section

########## BEGIN get subcommand ##########
if [[ "${subcommand}" == "get" ]]; then
  [ -f "${key_file}" ] || { echo_err "Key ${key} not found"; exit $CU_ERROR_NOT_FOUND; }
  cat "${key_file}" || { echo_err "Failed to get value for key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END get subcommand ##########

########## BEGIN set subcommand ##########
if [[ "${subcommand}" == "set" ]]; then
  [ -f "${key_file}" ] && { echo_err "Key ${key} in namespace ${namespace} already exists"; exit $CU_ERROR_ALREADY_EXISTS; }
  cat - > "${key_file}" || { echo_err "Failed to set value for key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  chmod 640 "${key_file}"
  exit
fi
########## END set subcommand ##########

########## BEGIN set_overwrite subcommand ##########
if [[ "${subcommand}" == "set_overwrite" ]]; then
  cat - > "${key_file}" || { echo_err "Failed to set value for key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END set_overwrite subcommand ##########

########## BEGIN delete subcommand ##########
if [[ "${subcommand}" == "delete" ]]; then
  [ -f "${key_file}" ] || { echo_err "Key ${key} not found"; exit $CU_ERROR_NOT_FOUND; }
  rm "${key_file}" > /dev/null 2>&1 || { echo_err "Failed to delete key ${key} in namespace ${namespace}"; exit $CU_ERROR; }
  exit
fi
########## END delete subcommand ##########

# END Critical section
