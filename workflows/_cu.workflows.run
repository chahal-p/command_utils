#!/usr/bin/env bash

[[ ":$PATH:" == *":/usr/local/bin:"* ]] || export PATH="/usr/local/bin:$PATH"
[[ ":$PATH:" == *":$HOME/.local/bin:"* ]] || export PATH="$HOME/.local/bin:$PATH"

######### Worker ID ##############################
PID="$$"
WORKER_ID="${1}"
[[ -n "${WORKER_ID}" ]] || { echo "No worker ID provided" >&2; exit 1; }
##################################################

######### Logging functions ######################
function log_info() {
  echo "[INFO] [WORKER ${PID}-${WORKER_ID}] $(cu.date) $1"
}

function log_error() {
  echo "[ERROR] [WORKER ${PID}-${WORKER_ID}] $(cu.date) $1" >&2
}
##################################################

######### Initialize user env ####################
USER="$(whoami)"
[[ -n "${USER}" ]] || { log_error "Failed to get user name"; exit 1; }
export USER
##################################################

######### Lock directory setup ###################
LOCK_DIR="/tmp/cu_workflows_locks_${USER}"
[[ -d "${LOCK_DIR}" ]] || mkdir -m 777 -p "${LOCK_DIR}" || exit
##################################################

######### Acquire worker ID lock #################
function acquire_worker_id_lock() {
  local lock_file
  lock_file="${LOCK_DIR}/worker_${WORKER_ID}.lock"
  (umask 000 && touch "${lock_file}") || { log_error "Failed to create lock file for worker ${WORKER_ID}"; exit 1; }
  exec 201<"${lock_file}"
  cu.lock --fd 201 --timeout 0 2>/dev/null
}
acquire_worker_id_lock || { log_error "Worker ${WORKER_ID} is busy"; exit 1; }
log_info "Acquired lock for worker ${WORKER_ID}"
##################################################

NAMESPACE_PREFIX="_cu_workflows"

function lock_workflow() {
  local name
  local lock_file
  name="$1"
  lock_file="${LOCK_DIR}/workflow_${name}.lock"
  (umask 000 && touch "${lock_file}") || { log_error "Failed to create lock file for workflow ${name}"; exit 1; }
  exec 200<"${lock_file}"
  cu.lock --fd 200 --timeout 0 2>/dev/null
}

function unlock_workflow() {
  exec 200<&-
}

function workflow_pop() {
  local name
  local scheduled_at
  name="$1"
  scheduled_at="$(_cu.persistent_kv get ${NAMESPACE_PREFIX}_scheduled_${USER} "$name" 2>/dev/null)" || return 1
  [[ ${scheduled_at} -le $(cu.date.to-epoch --out_nanoseconds) ]] || return 1
  return 0
}

function schedule_next_workflow() {
  local name
  local interval
  local code
  local scheduled_at
  name="$1"
  interval="$(_cu.persistent_kv get ${NAMESPACE_PREFIX}_intervals_${USER} "${name}" 2>/dev/null)"
  code=$?
  if [ $code -eq 40 ]; then
    _cu.persistent_kv delete ${NAMESPACE_PREFIX}_scheduled_${USER} "$name" 2>/dev/null
    return $code
  fi
  if [ $code -ne 0 ]; then
    log_error "Failed to get workflow interval for ${name}"
    return $code
  fi
  nanoseconds_interval="$(( interval * 1000000000 ))"
  scheduled_at="$(( $(cu.date.to-epoch --out_nanoseconds) + nanoseconds_interval ))"
  printf '%s' "$scheduled_at" | _cu.persistent_kv set_overwrite ${NAMESPACE_PREFIX}_scheduled_${USER} "$name"
}

function run_workflow() {
  local name
  local wf_encoded_cmd
  local code
  local wf_cmd
  name="$1"
  wf_encoded_cmd="$(_cu.persistent_kv get ${NAMESPACE_PREFIX}_${USER} "${name}" 2>/dev/null)"
  code=$?
  [ $code -eq 0 ] || { [ $code -eq 40 ] && { log_error "Workflow ${name} not found"; exit $code; } || exit $code; }

  wf_cmd=()
  IFS=':' read -ra wf_cmd <<< "$wf_encoded_cmd"

  for ((i = 0; i < ${#wf_cmd[@]}; i++)); do
    wf_cmd[i]="$(printf '%s' "${wf_cmd[i]}" | base64 -d)"
  done

  "${wf_cmd[@]}"
}

log_info "Checking for workflows ready to run"

wf_scheduled=()

read -d '\n' -a wfs < <(_cu.persistent_kv list ${NAMESPACE_PREFIX}_scheduled_${USER} 2>/dev/null)

for wf_name in "${wfs[@]}"; do
  wf_at=$(_cu.persistent_kv get ${NAMESPACE_PREFIX}_scheduled_${USER} "${wf_name}" 2>/dev/null)
  code=$?
  [ $code -eq 0 ] || { [ $code -eq 40 ] && continue || { log_error "Failed to get workflow scheduled time for ${wf_name}"; exit $code; } }
  [[ ${wf_at} -le $(cu.date.to-epoch --out_nanoseconds) ]] && wf_scheduled+=("${wf_name}:${wf_at}")
done

IFS=$'\n' sorted_wf_scheduled=($(printf "%s\n" "${wf_scheduled[@]}" | sort -t: -k2n,2n))

for wf_schedule in "${sorted_wf_scheduled[@]}"; do
  wf_name="${wf_schedule%:*}"
  lock_workflow "$wf_name" || continue
  workflow_pop "$wf_name" || { unlock_workflow; continue; }
  log_info "Running workflow ${wf_name}"
  run_workflow "$wf_name"
  log_info "Workflow ${wf_name} is done"
  schedule_next_workflow "$wf_name" && log_info "Workflow ${wf_name} is scheduled for next run"
  unlock_workflow
done
